import numpy as np
import pandas as pd
import scipy.stats as stat
import scipy.optimize as opt
import os
import matplotlib.pyplot as plt

# --- Parámetros de la distribución Gamma (Versión Vectorial) ---
def gamma_alpha_i(theta, s1):
  """Calcula el parámetro de forma alpha de Gamma de forma vectorial."""
  a0, a1 = theta[0], theta[1]
  return np.exp(a0 + a1 * s1)

def gamma_lambda_i(theta, s1):
  """Calcula el parámetro de escala lambda de Gamma de forma vectorial."""
  b0, b1 = theta[2], theta[3]
  return np.exp(b0 + b1 * s1)

# --- Funciones de Probabilidad (Versión Vectorial) ---
def probabilidad_gamma(theta, IT, s1):
  """
  Calcula el vector de probabilidades de fallo teóricas (CDF de Gamma).
  """
  # Aseguramos que s1 tenga la misma forma que IT si es un escalar
  if isinstance(s1, (int, float)):
      s1 = np.full_like(IT, s1, dtype=float)
      
  alphai = gamma_alpha_i(theta, s1)
  lambdai = gamma_lambda_i(theta, s1)
  return stat.gamma.cdf(IT, a=alphai, scale=lambdai)

def probabilidad_estimada(muestra, K):
  """Calcula el vector de probabilidades de fallo estimadas a partir de la muestra."""
  return muestra / K

# --- Función de Divergencia (Versión Vectorial) ---
def divergencia_gamma_vectorial(theta, alpha, IT, s1, K, muestra):
  """
  Calcula la divergencia de densidad de potencia (DPD) de forma totalmente vectorial.
  """
  eps = 1e-10

  pi_theta1 = probabilidad_gamma(theta, IT, s1)
  pi_theta1 = np.clip(pi_theta1, eps, 1.0 - eps) 
  pi_theta2 = 1 - pi_theta1
  
  p1 = probabilidad_estimada(muestra, K)
  p1 = np.clip(p1, eps, 1.0 - eps)
  p2 = 1 - p1
  
  if alpha == 0:
    div_vector = K * (p1 * np.log(p1 / pi_theta1) + p2 * np.log(p2 / pi_theta2))
  else:
    term1 = pi_theta1**(1 + alpha) + pi_theta2**(1 + alpha)
    term2 = (1 + 1/alpha) * (p1 * pi_theta1**alpha + p2 * pi_theta2**alpha)
    div_vector = K * (term1 - term2)
    
  total_divergence = np.sum(div_vector)
  K_total = len(muestra) * K
  
  return total_divergence / K_total

# --- Estimador y Ejecución ---
def emdp(theta_inicial, alpha, IT, s1, K, muestra):
  """Encuentra el estimador de mínima divergencia (EMDP)."""
  args = (alpha, IT, s1, K, muestra)
  result = opt.minimize(divergencia_gamma_vectorial, theta_inicial, args=args, method='L-BFGS-B')
  
  if not result.success:
      print(f"ADVERTENCIA: La optimización pudo haber fallado para alpha={alpha} con el mensaje: {result.message}")
      
  return result.x

def estimacion(theta_inicial, IT, s1, K, muestra, alphas):
  """
  Ejecuta la estimación para una lista de valores de alpha y guarda los resultados.
  """
  estimadores = []
  for alpha in alphas:
    emdp_estimado = emdp(theta_inicial, alpha, IT, s1, K, muestra)
    estimadores.append(emdp_estimado)
    print(f"Alpha: {alpha:.2f} -> Parámetros estimados: {emdp_estimado}")
    
  df_estimators = pd.DataFrame(estimadores, columns=[f"theta_{i+1}" for i in range(len(theta_inicial))])
  df_estimators["alpha"] = alphas
  
  output_path = "resultados_reales/"
  if not os.path.exists(output_path):
      os.makedirs(output_path) 
      
  filepath = os.path.join(output_path, "estimators_reales.csv")
  df_estimators.to_csv(filepath, index=False)
  print(f"\nArchivo CSV guardado en: '{filepath}'")
  
  return df_estimators

# --- Datos de Entrada ---
muestra = np.array([3, 1, 6, 3, 5, 7, 7, 7, 9])
K = 10
IT = np.array([10, 10, 10, 20, 20, 20, 30, 30, 30])
s1 = np.array([308, 318, 328, 308, 318, 328, 308, 318, 328])
theta_inicial = np.array([2.8, -0.01, 12,-0.015])
alphas = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7,0.8,0.9,1])

# --- Ejecución del Proceso Principal ---
np.set_printoptions(formatter={'float': '{:0.4f}'.format})
df_resultados = estimacion(theta_inicial, IT, s1, K, muestra, alphas)
print("\nEstimaciones Finales:")
print(df_resultados)


# =========================================================================
# === CÁLCULO DE VIDA MEDIA PARA MÚLTIPLES NIVELES DE ESTRÉS ===
# =========================================================================

def calcular_vida_media_multinivel(df_estimadores, niveles_s):
    """
    Calcula la vida media para cada conjunto de parámetros y para cada nivel de estrés.
    """
    thetas = df_estimadores[['theta_1', 'theta_2', 'theta_3', 'theta_4']].values
    
    # Preparamos el DataFrame de resultados, comenzando con la columna alpha
    results_df = df_estimadores[['alpha']].copy()
    
    # Iteramos sobre cada nivel de estrés para calcular la vida media
    for s_nivel in niveles_s:
        alphai = np.exp(thetas[:, 0] + thetas[:, 1] * s_nivel)
        lambdai = np.exp(thetas[:, 2] + thetas[:, 3] * s_nivel)
        
        vida_media = alphai * lambdai
        # Añadimos una nueva columna al DataFrame con un nombre descriptivo
        results_df[f'vida_media_s{s_nivel}'] = vida_media
        
    return results_df

# --- Ejecución del cálculo ---
output_path = "resultados_reales/"
niveles_de_estres = np.unique(s1) # Obtenemos los niveles únicos: [308, 318, 328]

df_vida_media_multinivel = calcular_vida_media_multinivel(df_resultados, niveles_de_estres)

# Guardamos los resultados
vida_media_filepath = os.path.join(output_path, "vida_media_multinivel_reales.csv")
df_vida_media_multinivel.to_csv(vida_media_filepath, index=False)

print(f"\nResultados de vida media multinivel guardados en '{vida_media_filepath}'.")
print("\nVida Media Calculada para cada Nivel de Estrés:")
print(df_vida_media_multinivel)


print("\n\n--- Código LaTeX para la tabla de Estimaciones Finales ---")
print(df_resultados.to_latex(index=True, float_format="%.5f"))

print("\n\n--- Código LaTeX para la tabla de Vida Media ---")
print(df_vida_media_multinivel.to_latex(index=False, float_format="%.4f"))


# =========================================================================
# === GRÁFICOS DE CDF ESTIMADAS PARA CADA NIVEL DE ESTRÉS ===
# =========================================================================

print("\nGenerando gráficos de las CDF estimadas para cada nivel de estrés...")

# Iteramos sobre cada nivel de estrés único para crear un gráfico por cada uno
for s_grafica in niveles_de_estres:
    
    # --- Preparación para el gráfico ---
    plt.figure(figsize=(12, 8))
    
    # 1. Graficar los puntos de datos empíricos para esta condición de estrés
    indices_s = np.where(s1 == s_grafica)
    IT_s = IT[indices_s]
    muestra_s = muestra[indices_s]
    p_estimada_s = muestra_s / K

    plt.scatter(IT_s, p_estimada_s, color='red', s=100, zorder=5, 
                label=f'Datos Observados (s1={s_grafica})')

    # 2. Generar y graficar una curva CDF para cada valor de alpha
    t_max = 40 
    t_values = np.linspace(0, t_max, 400)
    colors = plt.cm.viridis(np.linspace(0, 1, len(df_resultados)))

    for index, row in df_resultados.iterrows():
        theta_estimado = row[['theta_1', 'theta_2', 'theta_3', 'theta_4']].values
        alpha_val = row['alpha']
        
        # Calcular la CDF usando el s_grafica actual
        cdf_values = probabilidad_gamma(theta_estimado, t_values, s_grafica)
        
        plt.plot(t_values, cdf_values, label=f'α = {alpha_val:.2f}', color=colors[index], linewidth=2)

    # 3. Añadir detalles al gráfico
    plt.title(f'CDF de Falla Estimada para Nivel de Estrés s1 = {s_grafica}', fontsize=16)
    plt.xlabel('Tiempo (IT)', fontsize=12)
    plt.ylabel('Probabilidad Acumulada de Falla F(t)', fontsize=12)
    plt.legend(title="Estimador (alpha)", fontsize=10, loc='best')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.xlim(0, t_max)
    plt.ylim(0, 1)

    # 4. Guardar el gráfico con un nombre de archivo único
    plot_filename = os.path.join(output_path, f"cdf_estimadas_s{s_grafica}.png")
    plt.savefig(plot_filename, dpi=300)
    print(f"Gráfico guardado en: {plot_filename}")

# Muestra todos los gráficos generados al final de la ejecución
plt.show()
